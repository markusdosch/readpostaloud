<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>readpostaloud</title>
    <style>
    * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        line-height: 1.6;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        color: #333;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        color: #2c3e50;
        margin-top: 1.5em;
      }
      p {
        margin-bottom: 1em;
      }
      img {
        max-width: 100%;
        height: auto;
      } 
    </style>
    <style>
        .pill-menu {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            width: calc(100% - 40px);
            background-color: #6b7280;
            border-radius: 50px;
            padding: 12px 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
        }

        .menu-button {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .menu-button:hover,
        .menu-button:active {
            background-color: rgba(255, 255, 255, 0.2);
            transform: scale(0.95);
        }

        .language-select {
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            padding: 8px 12px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 16px;
            padding-right: 32px;
            min-width: 80px;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .language-select:hover,
        .language-select:focus {
            background-color: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            outline: none;
        }

        .language-select option {
            background-color: #374151;
            color: white;
            padding: 8px;
        }

        /* Play button icon */
        .play-icon::before {
            content: "▶️";
        }

        /* Pause button icon */
        .pause-icon::before {
            content: "⏸";
        }

        /* Stop button icon */
        .stop-icon::before {
            content: "⏹";
        }

    </style>
  </head>
  <body> 
  <div class="pill-menu">
        <button class="menu-button play-icon" aria-label="Play"></button>
        <button class="menu-button pause-icon" aria-label="Pause"></button>
        <button class="menu-button stop-icon" aria-label="Stop"></button>
        <select class="language-select" aria-label="Select language">
            <option value="en">English</option>
            <option value="de">German</option>
        </select>
    </div>
    <div class="placeholder" style="height:40px"></div>
    <h1>Dune vs Tailwind CSS: A Comparative Analysis</h1>
    <div class="article-content">
      <p>
        At first glance, Frank Herbert's epic science fiction novel "Dune" and
        Tailwind CSS might seem to inhabit entirely different universes, but
        both represent masterful approaches to building complex systems through
        modular design principles. Just as Paul Atreides must navigate the
        intricate political and ecological systems of Arrakis, developers using
        Tailwind CSS must master a vast ecosystem of utility classes to craft
        elegant user interfaces. Both require deep understanding of their
        respective domains—Herbert's universe demands comprehension of spice
        economics, religious movements, and desert survival, while Tailwind
        demands fluency in responsive design patterns, color theory, and modern
        CSS architecture.
      </p>
      <p>
        The philosophical underpinnings of both systems reveal striking
        parallels in their approach to power and control. In "Dune," the concept
        of prescience allows Paul to see multiple possible futures and choose
        the optimal path forward, much like how Tailwind's utility-first
        methodology gives developers the ability to rapidly prototype and
        iterate through design possibilities without being constrained by
        predetermined component structures. The Bene Gesserit's breeding program
        represents centuries of careful genetic manipulation toward a specific
        goal, mirroring how Tailwind's carefully curated utility classes have
        been refined through extensive real-world testing to provide maximum
        flexibility with minimal bloat.
      </p>
      <p>
        Both "Dune" and Tailwind CSS demonstrate how apparent complexity can
        emerge from elegant underlying principles. The seemingly chaotic desert
        planet of Arrakis operates according to precise ecological rules—from
        the sandworm lifecycle to the water conservation practices of the
        Fremen—just as Tailwind's thousands of utility classes follow consistent
        naming conventions and mathematical progressions that make the framework
        predictable once mastered. Herbert's novel shows how understanding these
        deeper patterns allows characters like Liet-Kynes to work with the
        desert rather than against it, while developers who embrace Tailwind's
        utility-first philosophy find themselves writing more maintainable CSS
        by working with the framework's grain rather than fighting it.
      </p>
      <p>
        The transformative impact of both works on their respective fields
        cannot be overstated. "Dune" revolutionized science fiction by proving
        that readers would embrace complex, politically sophisticated narratives
        that didn't shy away from challenging themes, paving the way for
        subsequent authors to explore deeper philosophical questions within
        genre fiction. Similarly, Tailwind CSS has fundamentally altered how
        developers approach styling by demonstrating that utility-first design
        can be more efficient and maintainable than traditional CSS
        methodologies, inspiring an entire generation of frameworks and design
        systems. Both represent paradigm shifts that initially faced skepticism
        but ultimately proved their worth through practical application and
        sustained influence on their communities.
      </p>
    </div>
    <script>
    let currentUtterance = null;
let isReading = false;
let isPaused = false;
    
        document.querySelector('.play-icon').addEventListener('click', readArticleAloud);

        document.querySelector('.pause-icon').addEventListener('click', pauseReading);

        document.querySelector('.stop-icon').addEventListener('click', stopReading);

        document.querySelector('.language-select').addEventListener('change', function() {
            console.log('Language changed to:', this.value);
        });
        
        function readArticleAloud() {
  // Check if speech synthesis is supported
  if (!('speechSynthesis' in window)) {
    console.error('Speech synthesis not supported in this browser');
    return;
  }
  
  if (isReading && isPaused) {
  resumeReading();
  return;
  }


  if (isReading) {
    return;
  }
  
  // Get the article content element
  const articleElement = document.querySelector('.article-content');
  
  if (!articleElement) {
    console.error('Element with class "article-content" not found');
    return;
  }

  // Get the text content
  const textContent = articleElement.textContent || articleElement.innerText;
  
  if (!textContent.trim()) {
    console.warn('No text content found to read');
    return;
  }

  // Create a new SpeechSynthesisUtterance instance
  currentUtterance = new SpeechSynthesisUtterance(textContent);
  
  // Configure the speech settings
  currentUtterance.rate = 1;      // Speed (0.1 to 10)
  currentUtterance.pitch = 1;     // Pitch (0 to 2)
  currentUtterance.volume = 1;    // Volume (0 to 1)
  currentUtterance.lang = 'en-US'; // Language
  
  // Set up event listeners
  currentUtterance.onstart = function() {
    isReading = true;
    isPaused = false;
    console.log('Speech started');
  };
  
  currentUtterance.onend = function() {
    isReading = false;
    isPaused = false;
    currentUtterance = null;
    console.log('Speech ended');
  };
  
  currentUtterance.onerror = function(event) {
    console.error('Speech synthesis error:', event.error);
    isReading = false;
    isPaused = false;
    currentUtterance = null;
  };

  // Start speaking
  speechSynthesis.speak(currentUtterance);
}

/**
 * Pauses the current speech synthesis
 */
function pauseReading() {
  if (!('speechSynthesis' in window)) {
    console.error('Speech synthesis not supported in this browser');
    return;
  }

  if (isReading && !isPaused) {
    speechSynthesis.pause();
    isPaused = true;
    console.log('Speech paused');
  } else if (!isReading) {
    console.warn('No speech is currently active to pause');
  } else if (isPaused) {
    console.warn('Speech is already paused');
  }
}

/**
 * Resumes the paused speech synthesis
 */
function resumeReading() {
  if (!('speechSynthesis' in window)) {
    console.error('Speech synthesis not supported in this browser');
    return;
  }

  if (isReading && isPaused) {
    speechSynthesis.resume();
    isPaused = false;
    console.log('Speech resumed');
  } else if (!isReading) {
    console.warn('No speech is currently active to resume');
  } else if (!isPaused) {
    console.warn('Speech is not paused');
  }
}

/**
 * Stops the current speech synthesis completely
 */
function stopReading() {
  if (!('speechSynthesis' in window)) {
    console.error('Speech synthesis not supported in this browser');
    return;
  }

  if (isReading) {
    speechSynthesis.cancel();
    isReading = false;
    isPaused = false;
    currentUtterance = null;
    console.log('Speech stopped');
  } else {
    console.warn('No speech is currently active to stop');
  }
}

/**
 * Gets the current state of the speech synthesis
 */
function getSpeechState() {
  return {
    isReading: isReading,
    isPaused: isPaused,
    isSupported: 'speechSynthesis' in window
  };
}
    </script>
  </body>
</html>
